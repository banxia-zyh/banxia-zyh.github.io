(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{506:function(e,v,t){"use strict";t.r(v);var a=t(4),_=Object(a.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("Java 集合大致可以分为两大体系，一个是 Collection，另一个是 Map；")]),e._v(" "),t("ul",[t("li",[e._v("Collection ：主要由List、Set、Queue接口组成，List代表有序、重复的集合；其中Set代表无序、不可重复的集合；Java 5 又增加了Queue体系集合，代表一种队列集合实现。")]),e._v(" "),t("li",[e._v("Map：则代表具有映射关系的键值对集合。")])]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("java.util.Collection")]),e._v("下关系简易图")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/banxia-zyh/img/img/Collection%E7%B1%BB%E5%9B%BE.png",alt:"Collection类图"}})]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("java.util.Map")]),e._v(" 下关系简易结构图：")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/banxia-zyh/img/img/Map%E7%B1%BB%E5%9B%BE-%E7%AE%80%E6%98%93.png",alt:"Map类图-简易"}})]),e._v(" "),t("h3",{attrs:{id:"collection"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#collection"}},[e._v("#")]),e._v(" Collection")]),e._v(" "),t("ul",[t("li",[t("strong",[t("code",[e._v("ArrayList")])]),e._v("："),t("strong",[e._v("线程不同步")]),e._v("。默认初始容量为 10，当数组大小不足时容量扩大为 1.5 倍。为追求效率，ArrayList 没有实现同步（synchronized），如果需要多个线程并发访问，用户可以手动同步，也可使用 Vector 替代。")]),e._v(" "),t("li",[t("strong",[t("code",[e._v("LinkedList")]),e._v("：")]),e._v(" "),t("strong",[e._v("线程不同步")]),e._v("。"),t("strong",[e._v("双向链接实现")]),e._v("。LinkedList 同时实现了 List 接口和 Deque 接口，也就是说它既可以看作一个顺序容器，又可以看作一个队列（Queue），同时又可以看作一个栈（Stack）。这样看来，LinkedList 简直就是个全能冠军。当你需要使用栈或者队列时，可以考虑使用 LinkedList，一方面是因为 Java 官方已经声明不建议使用 Stack 类，更遗憾的是，Java 里根本没有一个叫做 Queue 的类（它是个接口名字）。关于栈或队列，现在的首选是 ArrayDeque，它有着比 LinkedList（当作栈或队列使用时）有着更好的性能。")]),e._v(" "),t("li",[t("strong",[t("code",[e._v("Vector")])]),e._v("："),t("strong",[e._v("线程同步")]),e._v("。默认初始容量为 10，当数组大小不足时容量扩大为 2 倍。它的同步是通过 "),t("code",[e._v("Iterator")]),e._v(" 方法加 "),t("code",[e._v("synchronized")]),e._v(" 实现的。")]),e._v(" "),t("li",[t("strong",[t("code",[e._v("TreeSet")])]),e._v("："),t("strong",[e._v("线程不同步")]),e._v("，内部使用 "),t("code",[e._v("NavigableMap")]),e._v(" 操作。默认元素 “自然顺序” 排列，可以通过 "),t("code",[e._v("Comparator")]),e._v(" 改变排序。TreeSet 里面有一个 TreeMap（适配器模式）")]),e._v(" "),t("li",[t("strong",[t("code",[e._v("HashSet")])]),e._v("："),t("strong",[e._v("线程不同步")]),e._v("，内部使用 HashMap 进行数据存储，提供的方法基本都是调用 HashMap 的方法，所以两者本质是一样的。集合元素可以为 NULL。")]),e._v(" "),t("li",[t("strong",[t("code",[e._v("Set")])]),e._v("：Set 是一种不包含重复元素的 Collection，Set 最多只有一个 null 元素。Set 集合通常可以通过 Map 集合通过适配器模式得到。")])]),e._v(" "),t("h3",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[e._v("#")]),e._v(" Map")]),e._v(" "),t("ul",[t("li",[t("strong",[t("code",[e._v("TreeMap")])]),e._v("：线程不同步，基于 "),t("strong",[e._v("红黑树")]),e._v(" （Red-Black tree）的 NavigableMap 实现，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。\n"),t("ul",[t("li",[t("strong",[e._v("TreeMap 底层通过红黑树（Red-Black tree）实现")]),e._v("，也就意味着 "),t("code",[e._v("containsKey()")]),e._v(", "),t("code",[e._v("get()")]),e._v(", "),t("code",[e._v("put()")]),e._v(", "),t("code",[e._v("remove()")]),e._v(" 都有着 "),t("code",[e._v("log(n)")]),e._v(" 的时间复杂度。其具体算法实现参照了《算法导论》。")])])]),e._v(" "),t("li",[t("strong",[t("code",[e._v("Hashtable")])]),e._v("："),t("strong",[e._v("线程安全")]),e._v("，HashMap 的迭代器 (Iterator) 是 "),t("code",[e._v("fail-fast")]),e._v(" 迭代器。"),t("strong",[e._v("Hashtable 不能存储 NULL 的 key 和 value。")])]),e._v(" "),t("li",[t("strong",[t("code",[e._v("HashMap")])]),e._v("：线程不同步。根据 "),t("code",[e._v("key")]),e._v(" 的 "),t("code",[e._v("hashcode")]),e._v(" 进行存储，内部使用静态内部类 "),t("code",[e._v("Node")]),e._v(" 的数组进行存储，默认初始大小为 16，每次扩大一倍。当发生 Hash 冲突时，采用拉链法（链表）。JDK 1.8中："),t("strong",[e._v("当单个桶中元素个数大于等于8时，链表实现改为红黑树实现；当元素个数小于6时，变回链表实现。由此来防止hashCode攻击。")]),e._v(" "),t("ul",[t("li",[e._v("Java HashMap 采用的是冲突链表方式。")]),e._v(" "),t("li",[e._v("HashMap 是 Hashtable 的轻量级实现，可以接受为 null 的键值 (key) 和值 (value)，而 Hashtable 不允许。")])])]),e._v(" "),t("li",[e._v("**"),t("code",[e._v("LinkedHashMap")]),e._v("：**"),t("strong",[e._v("保存了记录的插入顺序")]),e._v("，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的。也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比 HashMap 慢，不过有种情况例外，当 HashMap 容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap 慢，因为 LinkedHashMap 的遍历速度只和实际数据有关，和容量无关，而 HashMap 的遍历速度和他的容量有关。")])]),e._v(" "),t("h3",{attrs:{id:"工具类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工具类"}},[e._v("#")]),e._v(" 工具类")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("Collections")]),e._v("、"),t("code",[e._v("Arrays")]),e._v("：集合类的一个工具类帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。")]),e._v(" "),t("li",[t("code",[e._v("Comparable")]),e._v("、"),t("code",[e._v("Comparator")]),e._v("：一般是用于对象的比较来实现排序，两者略有区别。")])]),e._v(" "),t("p",[t("strong",[e._v("说明")]),e._v("：线程不同步的时候可以通过，Collections.synchronizedList() 方法来包装一个线程同步方法")])])}),[],!1,null,null,null);v.default=_.exports}}]);